/*
 * KavaRef - A modernizing Java Reflection with Kotlin.
 * Copyright (C) 2019 HighCapable
 * https://github.com/HighCapable/KavaRef
 *
 * Apache License Version 2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * This file is created by fankes on 2025/5/16.
 */
@file:Suppress("UNCHECKED_CAST", "UnnecessaryVariable")

package com.highcapable.kavaref.resolver.processor

import com.highcapable.kavaref.condition.ConstructorCondition
import com.highcapable.kavaref.condition.FieldCondition
import com.highcapable.kavaref.condition.MethodCondition
import com.highcapable.kavaref.condition.base.ExecutableCondition
import com.highcapable.kavaref.condition.base.MemberCondition
import com.highcapable.kavaref.condition.matcher.base.TypeMatcher
import com.highcapable.kavaref.condition.type.Modifiers
import com.highcapable.kavaref.condition.type.VagueType
import com.highcapable.kavaref.extension.classOf
import com.highcapable.kavaref.extension.toClass
import com.highcapable.kavaref.extension.toClassOrNull
import com.highcapable.kavaref.generated.KavarefCoreProperties
import com.highcapable.kavaref.resolver.ConstructorResolver
import com.highcapable.kavaref.resolver.FieldResolver
import com.highcapable.kavaref.resolver.MethodResolver
import com.highcapable.kavaref.resolver.base.InstanceAwareResolver
import com.highcapable.kavaref.resolver.base.MemberResolver
import com.highcapable.kavaref.runtime.KavaRefRuntime
import java.lang.reflect.AnnotatedElement
import java.lang.reflect.Constructor
import java.lang.reflect.Executable
import java.lang.reflect.Field
import java.lang.reflect.Member
import java.lang.reflect.Method
import java.lang.reflect.Type
import kotlin.reflect.KClass

/**
 * Processing member resolver core implementation.
 */
object MemberProcessor {

    private const val PRODUCT_DESCRIPTION = "\n====== Generated by KavaRef ${KavarefCoreProperties.PROJECT_KAVAREF_CORE_VERSION} ======\n"

    /**
     * Global [Resolver] used by KavaRef to resolve members.
     *
     * You can change this resolver to use a custom member resolver, which will affect global behavior.
     */
    @JvmStatic
    var globalResolver: Resolver = Resolver()

    /**
     * Resolver class for resolving members.
     *
     * Provides methods to resolve fields, methods, and constructors of a class.
     *
     * You can inherit this class to implement a custom member parser,
     * and override the [getDeclaredFields], [getDeclaredMethods] and
     * [getDeclaredConstructors] methods to implement custom member resolution logic.
     */
    open class Resolver {

        /**
         * Resolve fields of the specified class [T].
         * @param declaringClass the class to resolve fields from.
         * @return [List]<[Field]>
         */
        open fun <T : Any> getDeclaredFields(declaringClass: Class<T>): List<Field> =
            runCatching { declaringClass.declaredFields.toList() }.onFailure {
                KavaRefRuntime.warn("Failed to get declared fields in $this because got an exception.", it)
            }.getOrNull() ?: emptyList()

        /**
         * Resolve methods of the specified class [T].
         * @param declaringClass the class to resolve methods from.
         * @return [List]<[Method]>
         */
        open fun <T : Any> getDeclaredMethods(declaringClass: Class<T>): List<Method> =
            runCatching { declaringClass.declaredMethods.toList() }.onFailure {
                KavaRefRuntime.warn("Failed to get declared methods in $this because got an exception.", it)
            }.getOrNull() ?: emptyList()

        /**
         * Resolve constructors of the specified class [T].
         * @param declaringClass the class to resolve constructors from.
         * @return [List]<[Constructor]<[T]>>
         */
        open fun <T : Any> getDeclaredConstructors(declaringClass: Class<T>): List<Constructor<T>> =
            runCatching { declaringClass.declaredConstructors.filterIsInstance<Constructor<T>>() }.onFailure {
                KavaRefRuntime.warn("Failed to get declared constructors in $this because got an exception.", it)
            }.getOrNull() ?: emptyList()
    }

    /**
     * Resolve members with current [condition] and [configuration].
     * @param condition the condition to resolve members.
     * @param configuration the configuration to resolve members, must not be null.
     * @return [List]<[R]>
     */
    internal inline fun <reified M : Member, reified R : MemberResolver<M, T>, T : Any> resolve(
        condition: MemberCondition<M, R, T>,
        configuration: MemberCondition.Configuration<T>?
    ): List<R> {
        require(configuration != null) {
            "You must provide a configuration to resolve the member use build(configuration)."
        }

        return when (condition) {
            is MethodCondition -> resolveInClass(
                condition, configuration, configuration.declaringClass
            ) { declaringClass ->
                methodFilters(condition, configuration, declaringClass)
            }

            is ConstructorCondition -> resolveInClass(
                condition, configuration, configuration.declaringClass
            ) { declaringClass ->
                constructorFilters(condition, configuration, declaringClass)
            }

            is FieldCondition -> resolveInClass(
                condition, configuration, configuration.declaringClass
            ) { declaringClass ->
                fieldFilters(condition, configuration, declaringClass)
            }

            else -> error("Unsupported condition type: $condition")
        } as List<R>
    }

    private fun <M : Member, R : MemberResolver<M, T>, T : Any> resolveInClass(
        condition: MemberCondition<M, R, T>,
        configuration: MemberCondition.Configuration<T>,
        declaringClass: Class<*>?,
        result: (declaringClass: Class<*>) -> List<R>
    ): List<R> {
        if (declaringClass == null || declaringClass == classOf<Any>())
            return throwIfNotOptional(condition, configuration)

        return result(declaringClass).ifEmpty {
            if (configuration.superclass)
                resolveInClass(condition, configuration, declaringClass.superclass, result)
            else throwIfNotOptional(condition, configuration)
        }
    }

    private fun <T : Any> methodFilters(
        condition: MethodCondition<T>,
        configuration: MemberCondition.Configuration<T>,
        declaringClass: Class<*>
    ): List<MethodResolver<T>> = configuration.currentProcessorResolver.getDeclaredMethods(declaringClass)
        .asSequence()
        .baseFilters(condition, configuration)
        .executableFilters(condition, configuration)
        .filter(configuration, MethodCondition.RETURN_TYPE, condition.returnType) { key, value ->
            value.returnType == key.toTypeClass(configuration, noVague = "Method: returnType")
        }
        .filter(configuration, MethodCondition.RETURN_TYPE_CONDITION, condition.returnTypeCondition) { key, value ->
            runOrElse { key(value.returnType) }
        }
        .filter(configuration, MethodCondition.IS_BRIDGE, condition.isBridge) { key, value -> value.isBridge == key }
        .filter(configuration, MethodCondition.IS_BRIDGE_NOT, condition.isBridgeNot) { key, value -> value.isBridge != key }
        .filter(configuration, MethodCondition.IS_DEFAULT, condition.isDefault) { key, value -> value.isDefault == key }
        .filter(configuration, MethodCondition.IS_DEFAULT_NOT, condition.isDefaultNot) { key, value -> value.isDefault != key }
        .resolve(configuration)

    private fun <T : Any> constructorFilters(
        condition: ConstructorCondition<T>,
        configuration: MemberCondition.Configuration<T>,
        declaringClass: Class<*>
    ): List<ConstructorResolver<T>> = configuration.currentProcessorResolver.getDeclaredConstructors(declaringClass)
        .asSequence()
        .baseFilters(condition, configuration)
        .executableFilters(condition, configuration)
        .resolve(configuration)

    private fun <T : Any> fieldFilters(
        condition: FieldCondition<T>,
        configuration: MemberCondition.Configuration<T>,
        declaringClass: Class<*>
    ): List<FieldResolver<T>> = configuration.currentProcessorResolver.getDeclaredFields(declaringClass)
        .asSequence()
        .baseFilters(condition, configuration)
        .filter(configuration, FieldCondition.IS_ENUM_CONSTANT, condition.isEnumConstant) { key, value -> value.isEnumConstant == key }
        .filter(configuration, FieldCondition.IS_ENUM_CONSTANT_NOT, condition.isEnumConstantNot) { key, value -> value.isEnumConstant != key }
        .filter(configuration, FieldCondition.TYPE, condition.type) { key, value ->
            value.type == key.toTypeClass(configuration, noVague = "Field: type")
        }
        .filter(configuration, FieldCondition.TYPE_CONDITION, condition.typeCondition) { key, value -> key(value.type) }
        .filter(configuration, FieldCondition.GENERIC_TYPE, condition.genericType) { key, value -> key.matches(value.genericType) }
        .filter(configuration, FieldCondition.GENERIC_TYPE_CONDITION, condition.genericTypeCondition) { key, value -> key(value.genericType) }
        .resolve(configuration)

    private fun <M : Member, T : Any> Sequence<M>.baseFilters(
        condition: MemberCondition<*, *, *>,
        configuration: MemberCondition.Configuration<T>
    ) = this.filter(configuration, MemberCondition.NAME, condition.name) { key, value -> value.name == key }
        .filter(configuration, MemberCondition.NAME_CONDITION, condition.nameCondition) { key, value -> runOrElse { key(value.name) } }
        .filter(configuration, MemberCondition.MODIFIERS, condition.modifiers) { key, value ->
            key.all { it.matches(value.modifiers) }
        }
        .filter(configuration, MemberCondition.MODIFIERS_NOT, condition.modifiersNot) { key, value ->
            key.none { it.matches(value.modifiers) }
        }
        .filter(configuration, MemberCondition.MODIFIERS_CONDITION, condition.modifiersCondition) { key, value ->
            runOrElse { key(Modifiers.matching(value.modifiers)) }
        }
        .filter(configuration, MemberCondition.IS_SYNTHETIC, condition.isSynthetic) { key, value -> value.isSynthetic == key }
        .filter(configuration, MemberCondition.IS_SYNTHETIC_NOT, condition.isSyntheticNot) { key, value -> value.isSynthetic != key }
        .filter(configuration, MemberCondition.ANNOTATIONS, condition.annotations) { key, value ->
            val annotations = value.annotations.map { it.annotationClass.java }
            compareElementTypes(key, annotations, configuration)
        }
        .filter(configuration, MemberCondition.ANNOTATIONS_NOT, condition.annotationsNot) { key, value ->
            val annotations = value.annotations.map { it.annotationClass.java }
            !compareElementTypes(key, annotations, configuration)
        }
        .filter(configuration, MemberCondition.GENERIC_STRING, condition.genericString) { key, value -> value.toGenericString() == key }

    private fun <M : Executable, T : Any> Sequence<M>.executableFilters(
        condition: ExecutableCondition<*, *, *>,
        configuration: MemberCondition.Configuration<T>
    ) = this
        .filter(configuration, ExecutableCondition.PARAMETERS, condition.parameters) { key, value ->
            compareElementTypes(key, value.parameterTypes.toList(), configuration)
        }
        .filter(configuration, ExecutableCondition.PARAMETERS_NOT, condition.parametersNot) { key, value ->
            !compareElementTypes(key, value.parameterTypes.toList(), configuration)
        }
        .filter(configuration, ExecutableCondition.PARAMETERS_CONDITION, condition.parametersCondition) { key, value ->
            runOrElse { key(value.parameterTypes.toList()) }
        }
        .filter(configuration, ExecutableCondition.PARAMETER_COUNT, condition.parameterCount) { key, value -> value.parameterCount == key }
        .filter(configuration, ExecutableCondition.PARAMETER_COUNT_CONDITION, condition.parameterCountCondition) { key, value ->
            runOrElse { key(value.parameterCount) }
        }
        .filter(configuration, ExecutableCondition.TYPE_PARAMETERS, condition.typeParameters) { key, value ->
            compareMatcherTypes(key, value.typeParameters.toList())
        }
        .filter(configuration, ExecutableCondition.TYPE_PARAMETERS_NOT, condition.typeParametersNot) { key, value ->
            !compareMatcherTypes(key, value.typeParameters.toList())
        }
        .filter(configuration, ExecutableCondition.EXCEPTION_TYPES, condition.exceptionTypes) { key, value ->
            compareElementTypes(key, value.exceptionTypes.toList(), configuration)
        }
        .filter(configuration, ExecutableCondition.EXCEPTION_TYPES_NOT, condition.exceptionTypesNot) { key, value ->
            !compareElementTypes(key, value.exceptionTypes.toList(), configuration)
        }
        .filter(configuration, ExecutableCondition.GENERIC_EXCEPTION_TYPES, condition.genericExceptionTypes) { key, value ->
            compareMatcherTypes(key, value.genericExceptionTypes.toList())
        }
        .filter(configuration, ExecutableCondition.GENERIC_EXCEPTION_TYPES_NOT, condition.genericExceptionTypesNot) { key, value ->
            !compareMatcherTypes(key, value.genericExceptionTypes.toList())
        }
        .filter(configuration, ExecutableCondition.GENERIC_PARAMETERS, condition.genericParameters) { key, value ->
            compareMatcherTypes(key, value.genericParameterTypes.toList())
        }
        .filter(configuration, ExecutableCondition.GENERIC_PARAMETERS_NOT, condition.genericParametersNot) { key, value ->
            !compareMatcherTypes(key, value.genericParameterTypes.toList())
        }
        .filter(configuration, ExecutableCondition.IS_VAR_ARGS, condition.isVarArgs) { key, value -> value.isVarArgs == key }
        .filter(configuration, ExecutableCondition.IS_VAR_ARGS_NOT, condition.isVarArgsNot) { key, value -> value.isVarArgs != key }
        .filter(configuration, ExecutableCondition.PARAMETER_ANNOTATIONS, condition.parameterAnnotations) { key, value ->
            val annotations = value.parameterAnnotations.map { it.map { e -> e.annotationClass.java } }
            compareElementTypes(key, annotations, configuration)
        }
        .filter(configuration, ExecutableCondition.PARAMETER_ANNOTATIONS_NOT, condition.parameterAnnotationsNot) { key, value ->
            val annotations = value.parameterAnnotations.map { it.map { e -> e.annotationClass.java } }
            !compareElementTypes(key, annotations, configuration)
        }
        .filter(configuration, ExecutableCondition.ANNOTATED_RETURN_TYPE, condition.annotatedReturnType) { key, value ->
            val annotations = value.annotatedReturnType.annotations.map { it.annotationClass.java }
            compareElementTypes(key, annotations, configuration)
        }
        .filter(configuration, ExecutableCondition.ANNOTATED_RETURN_TYPE_NOT, condition.annotatedReturnTypeNot) { key, value ->
            val annotations = value.annotatedReturnType.annotations.map { it.annotationClass.java }
            !compareElementTypes(key, annotations, configuration)
        }
        .filter(configuration, ExecutableCondition.ANNOTATED_RECEIVER_TYPE, condition.annotatedReceiverType) { key, value ->
            val annotations = value.annotatedReceiverType.annotations.map { it.annotationClass.java }
            compareElementTypes(key, annotations, configuration)
        }
        .filter(configuration, ExecutableCondition.ANNOTATED_RECEIVER_TYPE_NOT, condition.annotatedReceiverTypeNot) { key, value ->
            val annotations = value.annotatedReceiverType.annotations.map { it.annotationClass.java }
            !compareElementTypes(key, annotations, configuration)
        }
        .filter(configuration, ExecutableCondition.ANNOTATED_PARAMETER_TYPES, condition.annotatedParameterTypes) { key, value ->
            val annotations = value.annotatedParameterTypes.map { it.annotations.map { e -> e.annotationClass.java } }.flatten()
            compareElementTypes(key, annotations, configuration)
        }
        .filter(configuration, ExecutableCondition.ANNOTATED_PARAMETER_TYPES_NOT, condition.annotatedParameterTypesNot) { key, value ->
            val annotations = value.annotatedParameterTypes.map { it.annotations.map { e -> e.annotationClass.java } }.flatten()
            !compareElementTypes(key, annotations, configuration)
        }
        .filter(configuration, ExecutableCondition.ANNOTATED_EXCEPTION_TYPES, condition.annotatedExceptionTypes) { key, value ->
            val annotations = value.annotatedExceptionTypes.map { it.annotations.map { e -> e.annotationClass.java } }.flatten()
            compareElementTypes(key, annotations, configuration)
        }
        .filter(configuration, ExecutableCondition.ANNOTATED_EXCEPTION_TYPES_NOT, condition.annotatedExceptionTypesNot) { key, value ->
            val annotations = value.annotatedExceptionTypes.map { it.annotations.map { e -> e.annotationClass.java } }.flatten()
            !compareElementTypes(key, annotations, configuration)
        }

    private inline fun <reified M : Member, reified R : MemberResolver<M, T>, T : Any> Sequence<M>.resolve(
        configuration: MemberCondition.Configuration<T>
    ) = when (M::class) {
        Method::class -> map { MethodResolver<T>(it as Method).apply(configuration) }
        Constructor::class -> map { ConstructorResolver(it as Constructor<T>).apply(configuration) }
        Field::class -> map { FieldResolver<T>(it as Field).apply(configuration) }
        else -> error("Unsupported member type: $this")
    }.toList() as List<R>

    private fun <M : Member, R : MemberResolver<M, T>, T : Any> throwIfNotOptional(
        condition: MemberCondition<M, R, T>,
        configuration: MemberCondition.Configuration<T>
    ): List<R> {
        fun splicingString(name: String) = "No $name found matching the condition for " +
          "current class${if (configuration.superclass) " (Also tried for superclass)" else ""}.\n" +
          buildConditionTable(condition, configuration) + "\n" +
          "Suggestion: ${
              if (!configuration.superclass) "Members in superclass are not reflected in the current class, " +
                "you can try adding superclass() in your condition and try again. "
              else "Check if the conditions are correct and valid, and try again. "
          }"

        val exceptionNote = "If you want to ignore this exception, adding optional() in your condition."
        val message = when (condition) {
            is MethodCondition -> splicingString(name = "method")
            is ConstructorCondition -> splicingString(name = "constructor")
            is FieldCondition -> splicingString(name = "field")
            else -> error("Unsupported condition type: $condition")
        }

        return when (configuration.optional) {
            MemberCondition.Configuration.Optional.NO -> throw when (condition) {
                is MethodCondition -> NoSuchMethodException("$message\n$exceptionNote\n$PRODUCT_DESCRIPTION")
                is ConstructorCondition -> NoSuchMethodException("$message\n$exceptionNote\n$PRODUCT_DESCRIPTION")
                is FieldCondition -> NoSuchFieldException("$message\n$exceptionNote\n$PRODUCT_DESCRIPTION")
                else -> error("Unsupported condition type: $condition")
            }

            MemberCondition.Configuration.Optional.NOTICE -> {
                KavaRefRuntime.warn(message.trim())
                emptyList()
            }

            MemberCondition.Configuration.Optional.SILENT -> emptyList()
        }
    }

    private inline fun <reified M : Member, T : Any> MemberResolver<M, T>.apply(configuration: MemberCondition.Configuration<T>) =
        apply { configuration.memberInstance?.let { if (this is InstanceAwareResolver) of(it) } }

    private fun <T, R> Sequence<T>.filter(
        configuration: MemberCondition.Configuration<*>,
        name: String,
        key: R?,
        predicate: (key: R, value: T) -> Boolean
    ) = filter { condition ->
        val predicateKey = if (key is Collection<*>)
            key.takeIf { it.isNotEmpty() }
        else key

        predicateKey?.let {
            val result = predicate(it, condition)
            val sKey = VagueType.format(it)?.toStringIgnore()
            val sValue = condition?.toStringIgnore()

            if (configuration.optional != MemberCondition.Configuration.Optional.SILENT)
                KavaRefRuntime.debug("[FILTER] [${if (result) "HIT" else "MISS"}] $name: $sKey [RESOLVED] $sValue")

            result
        } ?: true
    }

    private fun <T : Any> compareElementTypes(
        conditionKey: Collection<Any>,
        typesValue: List<Class<*>>,
        configuration: MemberCondition.Configuration<T>
    ): Boolean {
        // If size is different at first, return false.
        if (conditionKey.size != typesValue.size) return false

        val isMatched = conditionKey
            .map { it.toTypeClass(configuration) }
            .filterIndexed { index, type ->
                val target = typesValue[index]
                type == classOf<VagueType>() || target == type
            }.size == typesValue.size

        return isMatched
    }

    @JvmName("compareElementTypesMultiple")
    private fun <T : Any> compareElementTypes(
        conditionKey: Collection<Collection<Any>>,
        typesValue: List<List<Class<*>>>,
        configuration: MemberCondition.Configuration<T>
    ): Boolean {
        // If size is different at first, return false.
        if (conditionKey.size != typesValue.size) return false

        val isMatched = conditionKey.filterIndexed { index, type ->
            val target = typesValue[index]
            compareElementTypes(type, target, configuration)
        }.size == typesValue.size

        return isMatched
    }

    private fun compareMatcherTypes(
        conditionKey: Collection<TypeMatcher>,
        typesValue: List<Type>
    ): Boolean {
        // If size is different at first, return false.
        if (conditionKey.size != typesValue.size) return false

        val isMatched = conditionKey.filterIndexed { index, type ->
            val target = typesValue[index]
            type.matches(target)
        }.size == typesValue.size

        return isMatched
    }

    private fun <T : Any> buildConditionTable(
        condition: MemberCondition<*, *, *>,
        configuration: MemberCondition.Configuration<T>
    ) = runCatching {
        fun displayWidth(str: String) = str.sumOf { if (it.code > 127L) 2L else 1L }.toInt()

        fun padDisplay(str: String, targetWidth: Int): String {
            val currentWidth = displayWidth(str)
            val padding = targetWidth - currentWidth
            return if (padding > 0) str + " ".repeat(padding) else str
        }

        val rows = condition.conditionStringMap.mapNotNull { (label, value) ->
            val displayValue = when (value) {
                null -> null
                is Function<*> -> "(Runtime Condition)"
                is Collection<*> -> if (value.isEmpty()) null else VagueType.format(value)
                else -> VagueType.format(value)
                // Remove the Kotlin reflection warning message.
            }?.toStringIgnore()
            displayValue?.let { label to it }
        }

        if (rows.isEmpty()) return configuration.declaringClass.toString()

        val originalLabelWidth = rows.maxOf { displayWidth(it.first) }
        val originalValueWidth = rows.maxOf { displayWidth(it.second) }

        val headerText = configuration.declaringClass.toStringIgnore()
        val headerWidth = displayWidth(headerText)

        val contentWidth = originalLabelWidth + originalValueWidth + 3 // 3: " | "

        // If header is wider, increase value column width.
        val extraPadding = (headerWidth - contentWidth).coerceAtLeast(0)

        val labelWidth = originalLabelWidth
        val valueWidth = originalValueWidth + extraPadding

        val border = "+-${"-".repeat(labelWidth)}-+-${"-".repeat(valueWidth)}-+"
        val headerBorder = "+-${"-".repeat(labelWidth + valueWidth + 3)}-+"
        val header = "| ${padDisplay(headerText, labelWidth + valueWidth + 3)} |"

        val content = rows.joinToString("\n") { (label, value) ->
            "| ${padDisplay(label, labelWidth)} | ${padDisplay(value, valueWidth)} |"
        }

        return listOf(headerBorder, header, border, content, border).joinToString("\n")
    }.getOrDefault("${configuration.declaringClass.toStringIgnore()}\nFailed to build condition table.")

    private val <T : Any> MemberCondition.Configuration<T>.currentProcessorResolver
        get() = processorResolver ?: globalResolver

    private val Member.annotations
        get() = when (this) {
            is AnnotatedElement -> declaredAnnotations
            else -> error("Unsupported member type: $this")
        }

    private fun Member.toGenericString() = when (this) {
        is Method -> toGenericString()
        is Constructor<*> -> toGenericString()
        is Field -> toGenericString()
        else -> error("Unsupported member type: $this")
    }

    private fun <T : Any> Any.toTypeClass(configuration: MemberCondition.Configuration<T>, noVague: String? = null): Class<*> {
        fun Class<*>.parseVagueType() =
            if (this == classOf<VagueType>())
                noVague?.let { error("VagueType is not supported for \"$it\".") } ?: this
            else this

        return when (this) {
            is Class<*> -> this
            is KClass<*> -> this.java
            is String -> if (configuration.optional == MemberCondition.Configuration.Optional.NO)
                toClass(configuration.declaringClass.classLoader)
            // If enabled optional mode, use the "Object.class" as the default return type when not found.
            else toClassOrNull(configuration.declaringClass.classLoader) ?: classOf<Any>()

            is VagueType -> javaClass
            else -> error("Unsupported type: $this, supported types are Class, KClass, String and VagueType.")
        }.parseVagueType()
    }

    private fun Any.toStringIgnore() = toString().replace(" (Kotlin reflection is not available)", "")

    private inline fun runOrElse(block: () -> Boolean) = runCatching(block).getOrDefault(false)
}